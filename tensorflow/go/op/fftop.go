// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// DO NOT EDIT
// This file was machine generated by github.com/ctava/tensorflow/tensorflow/go/genop/wrap
//
// WARNING: This generation of wrapper function for TensorFlow ops is in an
// experimental state. The generated API can change without notice.

package op

import tf "github.com/tensorflow/tensorflow/tensorflow/go"

// Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most
//
// 2 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 2
//   dimensions of `input` are replaced with their inverse 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifft2
// @end_compatibility
func IFFT2D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT2D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 3-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most 3 dimensions of `input`.
// 
// The inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:
// The inner-most dimension contains the `fft_length / 2 + 1` unique components of
// the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
// from the size of the inner-most 3 dimensions of `input`. If the FFT length used
// to compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [3]. The FFT length for each dimension.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most 3
//   dimensions of `input` are replaced with the `fft_length` samples of their
//   inverse 3D real Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.irfftn with 3 dimensions.
// @end_compatibility
func IRFFT3D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT3D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 1-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most dimension of `input`.
// 
// The inner-most dimension of `input` is assumed to be the result of `RFFT`: the
// `fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If
// `fft_length` is not provided, it is computed from the size of the inner-most
// dimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to
// compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [1]. The FFT length.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most
//   dimension of `input` is replaced with the `fft_length` samples of its inverse
//   1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.irfft
// @end_compatibility
func IRFFT(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 1-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most dimension of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the
// `fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,
// followed by the `fft_length / 2` positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [1]. The FFT length.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most
//   dimension of `input` is replaced with the `fft_length / 2 + 1` unique
//   frequency components of its 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfft
// @end_compatibility
func RFFT(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most
//
// 3 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 3
//   dimensions of `input` are replaced with their inverse 3D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifftn with 3 dimensions.
// @end_compatibility
func IFFT3D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT3D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 3-dimensional discrete Fourier Transform over the inner-most 3
//
// dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 3
//   dimensions of `input` are replaced with their 3D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fftn with 3 dimensions.
// @end_compatibility
func FFT3D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT3D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 2-dimensional discrete Fourier Transform over the inner-most
//
// 2 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 2
//   dimensions of `input` are replaced with their 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fft2
// @end_compatibility
func FFT2D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT2D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 2-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most 2 dimensions of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the
// `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
// of `output`: the zero-frequency term, followed by the `fft_length / 2`
// positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [2]. The FFT length for each dimension.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most 2
//   dimensions of `input` are replaced with their 2D Fourier Transform. The
//   inner-most dimension contains `fft_length / 2 + 1` unique frequency
//   components.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfft2
// @end_compatibility
func RFFT2D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT2D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 2-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most 2 dimensions of `input`.
// 
// The inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:
// The inner-most dimension contains the `fft_length / 2 + 1` unique components of
// the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
// from the size of the inner-most 2 dimensions of `input`. If the FFT length used
// to compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [2]. The FFT length for each dimension.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most 2
//   dimensions of `input` are replaced with the `fft_length` samples of their
//   inverse 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.irfft2
// @end_compatibility
func IRFFT2D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT2D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 1-dimensional discrete Fourier Transform over the inner-most
//
// dimension of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most
//   dimension of `input` is replaced with its 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fft
// @end_compatibility
func FFT(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 3-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most 3 dimensions of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the
// `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
// of `output`: the zero-frequency term, followed by the `fft_length / 2`
// positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [3]. The FFT length for each dimension.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most 3
//   dimensions of `input` are replaced with the their 3D Fourier Transform. The
//   inner-most dimension contains `fft_length / 2 + 1` unique frequency
//   components.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfftn with 3 dimensions.
// @end_compatibility
func RFFT3D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT3D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most
//
// dimension of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most
//   dimension of `input` is replaced with its inverse 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifft
// @end_compatibility
func IFFT(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 2-dimensional discrete Fourier Transform over the inner-most
//
// 2 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 2
//   dimensions of `input` are replaced with their inverse 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifft2
// @end_compatibility
func IFFT2D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT2D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 3-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most 3 dimensions of `input`.
// 
// The inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:
// The inner-most dimension contains the `fft_length / 2 + 1` unique components of
// the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
// from the size of the inner-most 3 dimensions of `input`. If the FFT length used
// to compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [3]. The FFT length for each dimension.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most 3
//   dimensions of `input` are replaced with the `fft_length` samples of their
//   inverse 3D real Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.irfftn with 3 dimensions.
// @end_compatibility
func IRFFT3D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT3D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 1-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most dimension of `input`.
// 
// The inner-most dimension of `input` is assumed to be the result of `RFFT`: the
// `fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If
// `fft_length` is not provided, it is computed from the size of the inner-most
// dimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to
// compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [1]. The FFT length.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most
//   dimension of `input` is replaced with the `fft_length` samples of its inverse
//   1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.irfft
// @end_compatibility
func IRFFT(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 1-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most dimension of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the
// `fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,
// followed by the `fft_length / 2` positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [1]. The FFT length.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most
//   dimension of `input` is replaced with the `fft_length / 2 + 1` unique
//   frequency components of its 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfft
// @end_compatibility
func RFFT(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 3-dimensional discrete Fourier Transform over the inner-most
//
// 3 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 3
//   dimensions of `input` are replaced with their inverse 3D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifftn with 3 dimensions.
// @end_compatibility
func IFFT3D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT3D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 3-dimensional discrete Fourier Transform over the inner-most 3
//
// dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 3
//   dimensions of `input` are replaced with their 3D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fftn with 3 dimensions.
// @end_compatibility
func FFT3D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT3D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 2-dimensional discrete Fourier Transform over the inner-most
//
// 2 dimensions of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most 2
//   dimensions of `input` are replaced with their 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fft2
// @end_compatibility
func FFT2D(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT2D",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 2-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most 2 dimensions of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the
// `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
// of `output`: the zero-frequency term, followed by the `fft_length / 2`
// positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [2]. The FFT length for each dimension.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most 2
//   dimensions of `input` are replaced with their 2D Fourier Transform. The
//   inner-most dimension contains `fft_length / 2 + 1` unique frequency
//   components.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfft2
// @end_compatibility
func RFFT2D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT2D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 2-dimensional discrete Fourier Transform of a real-valued
//
// signal over the inner-most 2 dimensions of `input`.
// 
// The inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:
// The inner-most dimension contains the `fft_length / 2 + 1` unique components of
// the DFT of a real-valued signal. If `fft_length` is not provided, it is computed
// from the size of the inner-most 2 dimensions of `input`. If the FFT length used
// to compute `input` is odd, it should be provided since it cannot be inferred
// properly.
//
// Arguments:
//	input: A complex64 tensor.
//	fft_length: An int32 tensor of shape [2]. The FFT length for each dimension.
//
// Returns A float32 tensor of the same rank as `input`. The inner-most 2
//   dimensions of `input` are replaced with the `fft_length` samples of their
//   inverse 2D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.irfft2
// @end_compatibility
func IRFFT2D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IRFFT2D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 1-dimensional discrete Fourier Transform over the inner-most
//
// dimension of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most
//   dimension of `input` is replaced with its 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.fft
// @end_compatibility
func FFT(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "FFT",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the 3-dimensional discrete Fourier Transform of a real-valued signal
//
// over the inner-most 3 dimensions of `input`.
// 
// Since the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the
// `fft_length / 2 + 1` unique components of the FFT for the inner-most dimension
// of `output`: the zero-frequency term, followed by the `fft_length / 2`
// positive-frequency terms.
//
// Arguments:
//	input: A float32 tensor.
//	fft_length: An int32 tensor of shape [3]. The FFT length for each dimension.
//
// Returns A complex64 tensor of the same rank as `input`. The inner-most 3
//   dimensions of `input` are replaced with the their 3D Fourier Transform. The
//   inner-most dimension contains `fft_length / 2 + 1` unique frequency
//   components.
// 
// @compatibility(numpy)
// Equivalent to np.fft.rfftn with 3 dimensions.
// @end_compatibility
func RFFT3D(scope *Scope, input tf.Output, fft_length tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "RFFT3D",
		Input: []tf.Input{
			input, fft_length, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}

// Compute the inverse 1-dimensional discrete Fourier Transform over the inner-most
//
// dimension of `input`.
//
// Arguments:
//	input: A complex64 tensor.
//
// Returns A complex64 tensor of the same shape as `input`. The inner-most
//   dimension of `input` is replaced with its inverse 1D Fourier Transform.
// 
// @compatibility(numpy)
// Equivalent to np.fft.ifft
// @end_compatibility
func IFFT(scope *Scope, input tf.Output)(output tf.Output) {
	if scope.Err() != nil {
		return
	}
	opspec := tf.OpSpec{
		Type: "IFFT",
		Input: []tf.Input{
			input, 
		},
	}
	op := scope.AddOperation(opspec)
	return op.Output(0)
}
