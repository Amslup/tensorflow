// Code generated by protoc-gen-go.
// source: tensorflow/core/framework/graph.proto
// DO NOT EDIT!

package tensorflow

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Represents the graph of operations
// TODO(sanjay): Also want to put the following somewhere:
// * random_seed
// * replicas: Do we stamp them out in python itself?
// * where to load parameters
// * optimizer info? does it go with the parameter layers/ops?
type GraphDef struct {
	Node []*NodeDef `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
	// Compatibility version of the graph.  See core/public/version.h for version
	// history.  The GraphDef version is distinct from the TensorFlow version.
	// Each release of TensorFlow will support a range of GraphDef versions.
	Version int32 `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	// EXPERIMENTAL. DO NOT USE OR DEPEND ON THIS YET.
	//
	// "library" provides user-defined functions.
	//
	// Naming:
	//   * library.function.name are in a flat namespace.
	//     NOTE: We may need to change it to be hierarchical to support
	//     different orgs. E.g.,
	//     { "/google/nn", { ... }},
	//     { "/google/vision", { ... }}
	//     { "/org_foo/module_bar", {...}}
	//     map<string, FunctionDefLib> named_lib;
	//   * If node[i].op is the name of one function in "library",
	//     node[i] is deemed as a function call. Otherwise, node[i].op
	//     must be a primitive operation supported by the runtime.
	//
	//
	// Function call semantics:
	//
	//   * The callee may start execution as soon as some of its inputs
	//     are ready. The caller may want to use Tuple() mechanism to
	//     ensure all inputs are ready in the same time.
	//
	//   * The consumer of return values may start executing as soon as
	//     the return values the consumer depends on are ready.  The
	//     consumer may want to use Tuple() mechanism to ensure the
	//     consumer does not start until all return values of the callee
	//     function are ready.
	Library *FunctionDefLibrary `protobuf:"bytes,2,opt,name=library" json:"library,omitempty"`
}

func (m *GraphDef) Reset()                    { *m = GraphDef{} }
func (m *GraphDef) String() string            { return proto.CompactTextString(m) }
func (*GraphDef) ProtoMessage()               {}
func (*GraphDef) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{0} }

func (m *GraphDef) GetNode() []*NodeDef {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GraphDef) GetLibrary() *FunctionDefLibrary {
	if m != nil {
		return m.Library
	}
	return nil
}

type NodeDef struct {
	// The name given to this operator. Used for naming inputs,
	// logging, visualization, etc.  Unique within a single GraphDef.
	// Must match the regexp "[A-Za-z0-9.][A-Za-z0-9_./]*".
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The operation name.  There may be custom parameters in attrs.
	// Op names starting with an underscore are reserved for internal use.
	Op string `protobuf:"bytes,2,opt,name=op" json:"op,omitempty"`
	// Each input is "node:src_output" with "node" being a string name and
	// "src_output" indicating which output tensor to use from "node". If
	// "src_output" is 0 the ":0" suffix can be omitted.  Regular inputs
	// may optionally be followed by control inputs that have the format
	// "^node".
	Input []string `protobuf:"bytes,3,rep,name=input" json:"input,omitempty"`
	// A (possibly partial) specification for the device on which this
	// node should be placed.
	// The expected syntax for this string is as follows:
	//
	// DEVICE_SPEC ::= COLOCATED_NODE | PARTIAL_SPEC
	//
	// COLOCATED_NODE ::= "@" NODE_NAME  // See NodeDef.name above.
	// PARTIAL_SPEC ::= ("/" CONSTRAINT) *
	// CONSTRAINT ::= ("job:" JOB_NAME)
	//              | ("replica:" [1-9][0-9]*)
	//              | ("task:" [1-9][0-9]*)
	//              | ( ("gpu" | "cpu") ":" ([1-9][0-9]* | "*") )
	//
	// Valid values for this string include:
	// * "@other/node"                         (colocate with "other/node")
	// * "/job:worker/replica:0/task:1/gpu:3"  (full specification)
	// * "/job:worker/gpu:3"                   (partial specification)
	// * ""                                    (no specification)
	//
	// If the constraints do not resolve to a single device (or if this
	// field is empty or not present), the runtime will attempt to
	// choose a device automatically.
	Device string `protobuf:"bytes,4,opt,name=device" json:"device,omitempty"`
	// Operation-specific graph-construction-time configuration.
	// Note that this should include all attrs defined in the
	// corresponding OpDef, including those with a value matching
	// the default -- this allows the default to change and makes
	// NodeDefs easier to interpret on their own.  However, if
	// an attr with a default is not specified in this list, the
	// default will be used.
	// The "names" (keys) must match the regexp "[a-z][a-z0-9_]+" (and
	// one of the names from the corresponding OpDef's attr field).
	// The values must have a type matching the corresponding OpDef
	// attr's type field.
	// TODO(josh11b): Add some examples here showing best practices.
	Attr map[string]*AttrValue `protobuf:"bytes,5,rep,name=attr" json:"attr,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodeDef) Reset()                    { *m = NodeDef{} }
func (m *NodeDef) String() string            { return proto.CompactTextString(m) }
func (*NodeDef) ProtoMessage()               {}
func (*NodeDef) Descriptor() ([]byte, []int) { return fileDescriptor5, []int{1} }

func (m *NodeDef) GetAttr() map[string]*AttrValue {
	if m != nil {
		return m.Attr
	}
	return nil
}

func init() {
	proto.RegisterType((*GraphDef)(nil), "tensorflow.GraphDef")
	proto.RegisterType((*NodeDef)(nil), "tensorflow.NodeDef")
}

var fileDescriptor5 = []byte{
	// 284 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x90, 0xcd, 0x4b, 0xc3, 0x40,
	0x10, 0xc5, 0xc9, 0x57, 0x63, 0x26, 0x7e, 0xc0, 0x8a, 0x10, 0x02, 0x4a, 0x2d, 0x0a, 0x41, 0x21,
	0x81, 0x7a, 0x11, 0x6f, 0x8a, 0x1f, 0x17, 0xf1, 0xe8, 0x55, 0xd2, 0x74, 0xa3, 0xa1, 0x71, 0x37,
	0x4c, 0x37, 0x29, 0xf9, 0xbb, 0xfc, 0x07, 0x9d, 0x6c, 0xa2, 0xed, 0xa1, 0x3d, 0xee, 0xcc, 0x7b,
	0xef, 0xf7, 0x76, 0xe0, 0x52, 0x71, 0xb1, 0x94, 0x98, 0x97, 0x72, 0x95, 0x64, 0x12, 0x79, 0x92,
	0x63, 0xfa, 0xcd, 0x57, 0x12, 0x17, 0xc9, 0x27, 0xa6, 0xd5, 0x57, 0x5c, 0xa1, 0x54, 0x92, 0xc1,
	0x5a, 0x16, 0x5e, 0xed, 0xb6, 0xa4, 0x4a, 0xe1, 0x47, 0x93, 0x96, 0x35, 0xef, 0x7d, 0x61, 0xb4,
	0x5b, 0x9b, 0xd7, 0x22, 0x53, 0x85, 0x14, 0xbd, 0x72, 0x22, 0x61, 0xef, 0xa5, 0x03, 0x3e, 0xf2,
	0x9c, 0x9d, 0x83, 0x2d, 0xe4, 0x9c, 0x07, 0xc6, 0xd8, 0x8a, 0xfc, 0xe9, 0x71, 0xbc, 0x0e, 0x89,
	0xdf, 0x68, 0xde, 0x49, 0x8e, 0xc0, 0x6d, 0x38, 0x2e, 0xc9, 0x1f, 0x58, 0x63, 0x23, 0x72, 0x58,
	0x02, 0x6e, 0x59, 0xcc, 0x30, 0xc5, 0x36, 0x30, 0x69, 0xe0, 0x4f, 0xcf, 0x36, 0x6d, 0xcf, 0x03,
	0x8c, 0xac, 0xaf, 0xbd, 0x6a, 0xf2, 0x63, 0x80, 0xfb, 0x97, 0xb6, 0x4f, 0x40, 0xea, 0x45, 0x40,
	0x23, 0xf2, 0x18, 0x80, 0x29, 0x2b, 0x9d, 0xe2, 0xb1, 0x03, 0x70, 0x0a, 0x51, 0xd5, 0x8a, 0x28,
	0x16, 0x3d, 0x0f, 0x61, 0x34, 0xe7, 0x4d, 0x91, 0xf1, 0xc0, 0xd6, 0xeb, 0x6b, 0xb0, 0xbb, 0x3f,
	0x07, 0x8e, 0x6e, 0x7a, 0xba, 0xa5, 0x69, 0x7c, 0x4f, 0xfb, 0x27, 0xa1, 0xb0, 0x0d, 0x1f, 0xc0,
	0xfb, 0x7f, 0x30, 0x1f, 0xac, 0x05, 0x6f, 0x07, 0xe2, 0x05, 0x38, 0xfa, 0x6a, 0x43, 0xf5, 0x93,
	0xcd, 0x9c, 0xce, 0xf2, 0xde, 0x2d, 0xef, 0xcc, 0x5b, 0x63, 0x36, 0xd2, 0xd7, 0xba, 0xf9, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0xf9, 0xaa, 0xb4, 0x5b, 0xb8, 0x01, 0x00, 0x00,
}
