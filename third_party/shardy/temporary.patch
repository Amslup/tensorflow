diff --git a/shardy/dialect/sdy/transforms/propagation/BUILD b/shardy/dialect/sdy/transforms/propagation/BUILD
index 8892d7d..062118d 100644
--- a/shardy/dialect/sdy/transforms/propagation/BUILD
+++ b/shardy/dialect/sdy/transforms/propagation/BUILD
@@ -254,7 +254,6 @@ cc_library(
         ":basic_factor_propagation",
         ":factor_propagation",
         ":sharding_projection",
-        ":utils",
         "//shardy/dialect/sdy/ir:dialect",
         "//shardy/dialect/sdy/transforms/common:macros",
         "@llvm-project//llvm:Support",
diff --git a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
index b9cb48f..4746c84 100644
--- a/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
+++ b/shardy/dialect/sdy/transforms/propagation/aggressive_factor_propagation.cc
@@ -17,7 +17,6 @@ limitations under the License.
 
 #include <cassert>
 #include <cstdint>
-#include <tuple>
 
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
@@ -25,7 +24,6 @@ limitations under the License.
 #include "mlir/Support/LLVM.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
-#include "shardy/dialect/sdy/transforms/propagation/utils.h"
 
 namespace mlir {
 namespace sdy {
@@ -41,46 +39,6 @@ bool updateTensorSharding(ShardingProjection& projection, int64_t tensorIndex,
       tensorIndex - projection.getNumOperands(), factorIndex, newAxes);
 }
 
-struct TensorIndexSize {
-  int64_t index;
-  int64_t size;
-};
-
-// Given a factor Fi with non-empty new axes, if tensor Tj contains this factor
-// and Tj/Fi is a prefix of the new axes, Tj is a source of this new axes.
-// Return a vector of source tensor per factor.
-SmallVector<TensorIndexSize> getFactorToSourceTensor(
-    const ShardingProjection& projection, ArrayRef<int64_t> factorSizes,
-    AxesPerFactorRef axesPerFactor) {
-  SmallVector<TensorIndexSize> factorToSourceTensor(
-      factorSizes.size(), {/*index=*/-1, /*size=*/-1});
-  for (const auto& [tensorIndex, tensorFactorShardings] :
-       llvm::enumerate(llvm::concat<const TensorFactorShardings>(
-           projection.getOperands(), projection.getResults()))) {
-    int64_t tensorSize = 1;
-    for (const auto& [factorIndex, _] :
-         tensorFactorShardings.factorIndexToSharding) {
-      tensorSize *= factorSizes[factorIndex];
-    }
-
-    for (const auto& [factorIndex, sharding] :
-         tensorFactorShardings.factorIndexToSharding) {
-      const bool isSource =
-          !axesPerFactor[factorIndex].empty() &&
-          isAxisListPrefixOf(axesPerFactor[factorIndex], sharding.axisRefs) !=
-              PrefixStatus::NOT_A_PREFIX;
-      // There may be multiple sources for the same factor. We take the one with
-      // largest tensor size.
-      TensorIndexSize& sourceTensor = factorToSourceTensor[factorIndex];
-      if (isSource && tensorSize > sourceTensor.size) {
-        sourceTensor.size = tensorSize;
-        sourceTensor.index = tensorIndex;
-      }
-    }
-  }
-  return factorToSourceTensor;
-}
-
 }  // namespace
 
 UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
@@ -108,9 +66,6 @@ UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
     return result;
   }
 
-  SmallVector<TensorIndexSize> factorToSourceTensor =
-      getFactorToSourceTensor(projection, factorSizes, axesPerFactor);
-
   // The propagation on each tensor is independent. This strategy can propagate
   // different shardings to different tensors along the same factor. Examples
   // are provided in the docstring of this class.
@@ -139,22 +94,9 @@ UpdateTensorShardings AggressiveFactorPropagation::propagateFactorShardings(
       }
     }
 
-    SmallVector<int> sortedFactorIndices = toSetBitsVector(factorUpdated);
-    // We sort the factors based on:
-    // 1. larger source tensor size first
-    // 2. smaller source tensor index first
-    // 3. smaller factor index first
-    // Unstable sort is fine because there is no equality in the candidates.
-    llvm::sort(sortedFactorIndices, [&](int64_t i, int64_t j) {
-      return std::forward_as_tuple(-factorToSourceTensor[i].size,
-                                   factorToSourceTensor[i].index, i) <
-             std::forward_as_tuple(-factorToSourceTensor[j].size,
-                                   factorToSourceTensor[j].index, j);
-    });
-
     // Resolve conflicts (overlapping sharding axes) between factors.
     bool tensorUpdated = false;
-    for (const int64_t factorIndex : sortedFactorIndices) {
+    for (const int64_t factorIndex : factorUpdated.set_bits()) {
       SmallVector<AxisRefAttr> newAxes = newSharding[factorIndex].axisRefs;
       truncateAxesByRemovingConflicts(
           newAxes,
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 79626b6..509398d 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,151 +1 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/llvm/lib/Linker/IRMover.cpp b/llvm/lib/Linker/IRMover.cpp
---- a/llvm/lib/Linker/IRMover.cpp
-+++ b/llvm/lib/Linker/IRMover.cpp
-@@ -595,11 +595,15 @@
-   if (!SGV)
-     return nullptr;
- 
-+  // If SGV is from dest, it was already materialized when dest was loaded.
-+  if (SGV->getParent() == &DstM)
-+    return nullptr;
-+
-   // When linking a global from other modules than source & dest, skip
-   // materializing it because it would be mapped later when its containing
-   // module is linked. Linking it now would potentially pull in many types that
-   // may not be mapped properly.
--  if (SGV->getParent() != &DstM && SGV->getParent() != SrcM.get())
-+  if (SGV->getParent() != SrcM.get())
-     return nullptr;
- 
-   Expected<Constant *> NewProto = linkGlobalValueProto(SGV, ForIndirectSymbol);
-diff -ruN --strip-trailing-cr a/llvm/test/ThinLTO/X86/Inputs/ditemplatevalueparameter-remap.ll b/llvm/test/ThinLTO/X86/Inputs/ditemplatevalueparameter-remap.ll
---- a/llvm/test/ThinLTO/X86/Inputs/ditemplatevalueparameter-remap.ll
-+++ b/llvm/test/ThinLTO/X86/Inputs/ditemplatevalueparameter-remap.ll
-@@ -0,0 +1,29 @@
-+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
-+target triple = "x86_64-unknown-linux-gnu"
-+
-+define void @_Z8thinlto1v() unnamed_addr {
-+  %3 = alloca i64, align 4
-+    #dbg_declare(ptr %3, !14, !DIExpression(), !15)
-+  ret void
-+}
-+
-+!llvm.dbg.cu = !{!0}
-+!llvm.module.flags = !{!2, !3, !4, !5}
-+
-+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "clang", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
-+!1 = !DIFile(filename: "B.cpp", directory: ".")
-+!2 = !{i32 7, !"Dwarf Version", i32 4}
-+!3 = !{i32 2, !"Debug Info Version", i32 3}
-+!4 = !{i32 1, !"wchar_size", i32 4}
-+!5 = !{i32 8, !"PIC Level", i32 2}
-+!10 = distinct !DISubprogram(name: "thinlto1", linkageName: "_Z8thinlto1v", scope: !11, file: !11, line: 8, type: !12, scopeLine: 8, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)
-+!11 = !DIFile(filename: "b.cpp", directory: ".")
-+!12 = !DISubroutineType(types: !13)
-+!13 = !{null}
-+!14 = !DILocalVariable(name: "a", arg: 1, scope: !10, file: !11, line: 18, type: !16)
-+!15 = !DILocation(line: 18, column: 19, scope: !10)
-+!16 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "S<&func1>", file: !11, line: 2, size: 8, flags: DIFlagTypePassByValue, elements: !17, templateParams: !18, identifier: "_ZTS1SIXadL_Z5func1vEEE")
-+!17 = !{}
-+!18 = !{!19}
-+!19 = !DITemplateValueParameter(name: "Func", type: !20, value: ptr undef)
-+!20 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !12, size: 64)
-diff -ruN --strip-trailing-cr a/llvm/test/ThinLTO/X86/ditemplatevalueparameter-remap.ll b/llvm/test/ThinLTO/X86/ditemplatevalueparameter-remap.ll
---- a/llvm/test/ThinLTO/X86/ditemplatevalueparameter-remap.ll
-+++ b/llvm/test/ThinLTO/X86/ditemplatevalueparameter-remap.ll
-@@ -0,0 +1,93 @@
-+; https://github.com/llvm/llvm-project/pull/110064
-+; This test case checks if thinLTO correctly links metadata values in a specific
-+; situation. Assume we are linking module B into module A, where an extern
-+; function used in A is defined in B, but the function body has a
-+; DITemplateValueParameter referring to another function back in A. The
-+; compiler must check this other function is actually coming from A, thus
-+; already materialized and does not require remapping. The IR here is modified
-+; from the following source code.
-+;
-+; // A.h
-+; template <void (*Func)()>
-+; struct S {
-+;   void Impl() {
-+;     Func();
-+;   }
-+; };
-+;
-+; void func1();
-+;
-+; // A.cpp
-+; #include "A.h"
-+; __attribute__((weak)) void func1() {}
-+; extern void thinlto1();
-+; void bar() {
-+;   S<func1> s; // Force instantiation of S<func1> in this compilation unit.
-+;   s.Impl();
-+;   thinlto1();
-+; }
-+;
-+; // B.cpp
-+; #include "A.h"
-+; void thinlto1() {
-+;   S<func1> s;
-+; }
-+;
-+; RUN: opt -module-summary -o %t1.bc %s
-+; RUN: opt -module-summary -o %t2.bc %S/Inputs/ditemplatevalueparameter-remap.ll
-+; RUN: llvm-lto2 run %t1.bc %t2.bc -o %t3 -save-temps \
-+; RUN:   -r=%t1.bc,_Z5func1v,p    \
-+; RUN:   -r=%t1.bc,_Z3bazv,px     \
-+; RUN:   -r=%t1.bc,_Z8thinlto1v,x \
-+; RUN:   -r=%t1.bc,_Z3barv,px     \
-+; RUN:   -r=%t2.bc,_Z8thinlto1v,px
-+; RUN: llvm-dis %t3.1.4.opt.bc -o - | FileCheck %s
-+
-+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
-+target triple = "x86_64-unknown-linux-gnu"
-+
-+$_Z5func1v = comdat any
-+
-+define linkonce_odr void @_Z5func1v() unnamed_addr !dbg !10 {
-+  ret void
-+}
-+
-+; Dummy function to use _Z5func1v so that it is not treated as dead symbol.
-+define void @_Z3bazv() {
-+  tail call void @_Z5func1v()
-+  ret void
-+}
-+
-+declare void @_Z8thinlto1v() unnamed_addr
-+
-+; Check _Z8thinlto1v is inlined after thinLTO.
-+; CHECK: void @_Z3barv()
-+; CHECK-NOT: @_Z8thinlto1v()
-+; CHECK-NEXT: ret void
-+define void @_Z3barv() unnamed_addr !dbg !14 {
-+  tail call void @_Z8thinlto1v(), !dbg !25
-+  ret void
-+}
-+
-+!llvm.dbg.cu = !{!0}
-+!llvm.module.flags = !{!2, !3, !4, !5}
-+
-+!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus_14, file: !1, producer: "clang", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
-+!1 = !DIFile(filename: "A.cpp", directory: ".")
-+!2 = !{i32 7, !"Dwarf Version", i32 4}
-+!3 = !{i32 2, !"Debug Info Version", i32 3}
-+!4 = !{i32 1, !"wchar_size", i32 4}
-+!5 = !{i32 8, !"PIC Level", i32 2}
-+!10 = distinct !DISubprogram(name: "func1", linkageName: "_Z5func1v", scope: !11, file: !11, line: 6, type: !12, scopeLine: 6, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0)
-+!11 = !DIFile(filename: "a.h", directory: ".")
-+!12 = !DISubroutineType(types: !13)
-+!13 = !{null}
-+!14 = distinct !DISubprogram(name: "bar", linkageName: "_Z3barv", scope: !11, file: !11, line: 15, type: !12, scopeLine: 15, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !16)
-+!16 = !{!17}
-+!17 = !DILocalVariable(name: "s", scope: !14, file: !11, line: 10, type: !18)
-+!18 = distinct !DICompositeType(tag: DW_TAG_structure_type, name: "S<&func1>", file: !11, line: 2, size: 8, flags: DIFlagTypePassByValue, elements: !19, templateParams: !20, identifier: "_ZTS1SIXadL_Z5func1vEEE")
-+!19 = !{}
-+!20 = !{!21}
-+!21 = !DITemplateValueParameter(name: "Func", type: !22, value: ptr @_Z5func1v)
-+!22 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !12, size: 64)
-+!25 = !DILocation(line: 16, column: 5, scope: !14)
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 2d60ea0..07b64d5 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "33363521ca24f912cc25530f6cecbca53acce8a3"
-    LLVM_SHA256 = "3fd9cbd992ed880e348d81715f39138538fd6c8e9164b981551a97181a3b7b24"
+    LLVM_COMMIT = "7a710110fcb2ad5d903ec41ba6a63193cf03edc0"
+    LLVM_SHA256 = "9132a8cd2bb6abbf991dda7bd997636367698acaad0a0404e35bad59835bbb64"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 8b13789..2eb32ea 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -1 +1,83 @@
+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
+--- stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
++++ stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
+@@ -47,36 +47,36 @@
+   return shapedType;
+ }
+ 
+-std::optional<Value> materializeCastFromIllegal(OpBuilder &builder, Type type,
++Value materializeCastFromIllegal(OpBuilder &builder, Type type,
+                                                 ValueRange inputs,
+                                                 Location loc) {
+   Type fromType = getElementTypeOrSelf(inputs[0].getType());
+   Type toType = getElementTypeOrSelf(type);
+   if ((!fromType.isSignedInteger() && !fromType.isUnsignedInteger()) ||
+       !toType.isSignlessInteger())
+-    return std::nullopt;
++    return Value();
+   // Use unrealized conversion casts to do signful->signless conversions.
+   return builder.create<UnrealizedConversionCastOp>(loc, type, inputs[0])
+       ->getResult(0);
+ }
+ 
+-std::optional<Value> materializeCastToIllegal(OpBuilder &builder, Type type,
++Value materializeCastToIllegal(OpBuilder &builder, Type type,
+                                               ValueRange inputs, Location loc) {
+   Type fromType = getElementTypeOrSelf(inputs[0].getType());
+   Type toType = getElementTypeOrSelf(type);
+   if (!fromType.isSignlessInteger() ||
+       (!toType.isSignedInteger() && !toType.isUnsignedInteger()))
+-    return std::nullopt;
++    return Value();
+   // Use unrealized conversion casts to do signless->signful conversions.
+   return builder.create<UnrealizedConversionCastOp>(loc, type, inputs[0])
+       ->getResult(0);
+ }
+ 
+-std::optional<Value> scalarToTensor(OpBuilder &builder, Type type,
++Value scalarToTensor(OpBuilder &builder, Type type,
+                                     ValueRange inputs, Location loc) {
+   assert(inputs.size() == 1);
+   if (mlir::isa<ShapedType>(inputs.front().getType())) {
+-    return std::nullopt;
++    return Value();
+   }
+   Value result =
+       builder
+diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
+--- stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
++++ stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
+@@ -0,0 +1,15 @@
++// RUN: stablehlo-opt --stablehlo-legalize-to-vhlo --vhlo-to-version='target=1.4.1' %s | FileCheck %s
++
++// AllToAll was in the initial StableHLO opset, but changed in v1.5.0 to have
++// tuple arguments. Ensure that serializing for 1.4.1 is valid and targets the
++// v1.4.0 opset.
++//
++// This will catch issues in op `isLegal` checks:
++//   op.minVersion() <= target <= op.maxVersion()
++
++// CHECK-LABEL: vhlo.func_v1 @all_to_all
++func.func public @all_to_all(%arg0: tensor<8x8x1xui16>) -> tensor<1x8x8xui16> {
++  // CHECK: vhlo.all_to_all_v1
++  %0 = "stablehlo.all_to_all"(%arg0) <{concat_dimension = 2 : i64, replica_groups = dense<[[0, 1, 2, 3, 4, 5, 6, 7]]> : tensor<1x8xi64>, split_count = 8 : i64, split_dimension = 0 : i64}> : (tensor<8x8x1xui16>) -> tensor<1x8x8xui16>
++  return %0 : tensor<1x8x8xui16>
++}
+diff --ruN a/stablehlo/stablehlo/transforms/VhloToVersion.cpp b/stablehlo/stablehlo/transforms/VhloToVersion.cpp
+--- stablehlo/stablehlo/transforms/VhloToVersion.cpp
++++ stablehlo/stablehlo/transforms/VhloToVersion.cpp
+@@ -92,6 +92,13 @@
+                                    << " is greater than current version "
+                                    << Version::getCurrentVersion();
+ 
++  // Opset changes warrant a minor version bump, so this conversion assumes
++  // patch v0 since it is written against the opset at version `X.Y.0`.
++  if (targetVersion.getPatch() != 0) {
++    targetVersion =
++        vhlo::Version(targetVersion.getMajor(), targetVersion.getMinor(), 0);
++  }
++
+   return targetVersion;
+ }
+ 
 
diff --git a/third_party/stablehlo/workspace.bzl b/third_party/stablehlo/workspace.bzl
index 3eb32b8..f861cbc 100644
--- a/third_party/stablehlo/workspace.bzl
+++ b/third_party/stablehlo/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive", "tf_mirror_urls")
 
 def repo():
     #
-    STABLEHLO_COMMIT = "6e403b1aa6a71f5eaa09cc720e4ad42f692745e6"
-    STABLEHLO_SHA256 = "0ab812a5a07cc2d34ddda83aad1ad5d264d4879f5f9eb33a557c7c18dc763e4c"
+    STABLEHLO_COMMIT = "1c0b606503aac4f8e01f5511b0a10418bf93e7a6"
+    STABLEHLO_SHA256 = "9ccf08c7d2c7dc0a5c314cf13e3e82faafc8c3dc2a45f4d6fa634ca8e5e97705"
     #
 
     tf_http_archive(
