diff --git a/src/cpu/x64/gemm/gemm_driver.cpp b/src/cpu/x64/gemm/gemm_driver.cpp
index 0291e024a0..a15d3c12cc 100644
--- a/src/cpu/x64/gemm/gemm_driver.cpp
+++ b/src/cpu/x64/gemm/gemm_driver.cpp
@@ -1548,6 +1548,19 @@ static inline void adjust_thread_count(dim_t m, dim_t n, dim_t k, int *nthrs) {
     double gemm_cycles = m * n * k / fp_per_cycle;
     gemm_cycles *= is_f32 ? 2.0 : 8.0;
 
+#if DNNL_CPU_RUNTIME == DNNL_RUNTIME_THREADPOOL
+    if (is_avx512 && is_f32) {
+        auto l2_cache_per_thread = platform::get_per_core_cache_size(2);
+        int n_cores_per_socket = static_cast<int>(platform::get_num_cores());
+        auto l2_cache_socket = l2_cache_per_thread * n_cores_per_socket;
+        auto problem_memory_footprint = (m * n + m * k + n * k) * sizeof(float);
+        if (l2_cache_socket > problem_memory_footprint) {
+            *nthrs = nstl::min(*nthrs, n_cores_per_socket);
+            return;
+        }
+    }
+#endif
+
     int i = *nthrs;
 
     // Use a different model for omp overheads if nthrs is <= 4
diff --git a/src/cpu/x64/gemm/gemv_driver.cpp b/src/cpu/x64/gemm/gemv_driver.cpp
index a00e98f77c..618c087ac1 100644
--- a/src/cpu/x64/gemm/gemv_driver.cpp
+++ b/src/cpu/x64/gemm/gemv_driver.cpp
@@ -1,5 +1,5 @@
 /*******************************************************************************
-* Copyright 2019-2021 Intel Corporation
+* Copyright 2019-2022 Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
@@ -264,6 +264,17 @@ static inline int thread_checker(
                         dim_t(nthr));
             }
         }
+#if DNNL_CPU_RUNTIME == DNNL_RUNTIME_THREADPOOL
+        if (mayiuse(avx512_core) && is_f32) {
+            auto l2_cache = platform::get_per_core_cache_size(2) * nthr;
+            auto problem_memory_footprint = m * n * sizeof(float);
+            if (l2_cache > problem_memory_footprint) {
+                int n_cores_per_socket
+                        = static_cast<int>(platform::get_num_cores());
+                return nstl::min(nthr, n_cores_per_socket);
+            }
+        }
+#endif
     } else {
         if (trans) {
             if (MIN_WIDTH * nthr > m) nthr = utils::div_up(m, MIN_WIDTH);

