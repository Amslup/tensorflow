diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 7bed258..509398d 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,43 +1 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/llvm/lib/Target/X86/X86ISelLowering.cpp b/llvm/lib/Target/X86/X86ISelLowering.cpp
---- a/llvm/lib/Target/X86/X86ISelLowering.cpp
-+++ b/llvm/lib/Target/X86/X86ISelLowering.cpp
-@@ -50049,8 +50049,9 @@
-   SDValue X, Y, Z;
-   if (sd_match(N, m_And(m_Value(X),
-                         m_OneUse(m_Or(m_Value(Y), m_Not(m_Value(Z))))))) {
--    // Don't fold if Y is a constant to prevent infinite loops.
--    if (!isa<ConstantSDNode>(Y))
-+    // Don't fold if Y or Z are constants to prevent infinite loops.
-+    if (!DAG.isConstantIntBuildVectorOrConstantInt(Y) &&
-+        !DAG.isConstantIntBuildVectorOrConstantInt(Z))
-       return DAG.getNode(
-           ISD::AND, DL, VT, X,
-           DAG.getNOT(
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/pr108731.ll b/llvm/test/CodeGen/X86/pr108731.ll
---- a/llvm/test/CodeGen/X86/pr108731.ll
-+++ b/llvm/test/CodeGen/X86/pr108731.ll
-@@ -192,3 +192,23 @@
-   ret void
- }
- 
-+define void @PR113240(i64 %a) {
-+; CHECK-LABEL: PR113240:
-+; CHECK:       # %bb.0: # %entry
-+; CHECK-NEXT:    movq %rdi, %rax
-+; CHECK-NEXT:    notq %rax
-+; CHECK-NEXT:    movabsq $8796093022206, %rcx # imm = 0x7FFFFFFFFFE
-+; CHECK-NEXT:    notq %rcx
-+; CHECK-NEXT:    orq %rax, %rcx
-+; CHECK-NEXT:    andq %rdi, %rcx
-+; CHECK-NEXT:    movq %rcx, 0
-+; CHECK-NEXT:    retq
-+entry:
-+  %and = and i64 %a, 8796093022206
-+  %bf.value = and i64 8796093022206, 0
-+  %not = xor i64 %and, -1
-+  %and4 = and i64 %a, %not
-+  store i64 %and4, ptr null, align 8
-+  ret void
-+}
-+
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index a3d8da0..2d60ea0 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "6c4267fb1779bc5550bb413f33250f9365acfbc6"
-    LLVM_SHA256 = "7010ee8fe86246fabcaedbed21fa9ac2bd2542e0d2ad6172a4481e0294fdf354"
+    LLVM_COMMIT = "33363521ca24f912cc25530f6cecbca53acce8a3"
+    LLVM_SHA256 = "3fd9cbd992ed880e348d81715f39138538fd6c8e9164b981551a97181a3b7b24"
 
     tf_http_archive(
         name = name,
diff --git a/third_party/stablehlo/temporary.patch b/third_party/stablehlo/temporary.patch
index 4a1d725..2eb32ea 100755
--- a/third_party/stablehlo/temporary.patch
+++ b/third_party/stablehlo/temporary.patch
@@ -1,3 +1,49 @@
+diff --ruN a/stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp b/stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
+--- stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
++++ stablehlo/stablehlo/conversions/linalg/transforms/TypeConversion.cpp
+@@ -47,36 +47,36 @@
+   return shapedType;
+ }
+ 
+-std::optional<Value> materializeCastFromIllegal(OpBuilder &builder, Type type,
++Value materializeCastFromIllegal(OpBuilder &builder, Type type,
+                                                 ValueRange inputs,
+                                                 Location loc) {
+   Type fromType = getElementTypeOrSelf(inputs[0].getType());
+   Type toType = getElementTypeOrSelf(type);
+   if ((!fromType.isSignedInteger() && !fromType.isUnsignedInteger()) ||
+       !toType.isSignlessInteger())
+-    return std::nullopt;
++    return Value();
+   // Use unrealized conversion casts to do signful->signless conversions.
+   return builder.create<UnrealizedConversionCastOp>(loc, type, inputs[0])
+       ->getResult(0);
+ }
+ 
+-std::optional<Value> materializeCastToIllegal(OpBuilder &builder, Type type,
++Value materializeCastToIllegal(OpBuilder &builder, Type type,
+                                               ValueRange inputs, Location loc) {
+   Type fromType = getElementTypeOrSelf(inputs[0].getType());
+   Type toType = getElementTypeOrSelf(type);
+   if (!fromType.isSignlessInteger() ||
+       (!toType.isSignedInteger() && !toType.isUnsignedInteger()))
+-    return std::nullopt;
++    return Value();
+   // Use unrealized conversion casts to do signless->signful conversions.
+   return builder.create<UnrealizedConversionCastOp>(loc, type, inputs[0])
+       ->getResult(0);
+ }
+ 
+-std::optional<Value> scalarToTensor(OpBuilder &builder, Type type,
++Value scalarToTensor(OpBuilder &builder, Type type,
+                                     ValueRange inputs, Location loc) {
+   assert(inputs.size() == 1);
+   if (mlir::isa<ShapedType>(inputs.front().getType())) {
+-    return std::nullopt;
++    return Value();
+   }
+   Value result =
+       builder
 diff --ruN a/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir b/stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
 --- stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
 +++ stablehlo/stablehlo/tests/vhlo/vhlo_to_version_downgrade_patch.mlir
